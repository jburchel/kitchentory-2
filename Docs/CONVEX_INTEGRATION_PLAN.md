# Convex Integration Plan for Kitchentory NextJS Project

## Overview

This document provides a comprehensive, ready-to-execute plan for integrating Convex with the Kitchentory NextJS project. Convex serves as the real-time database and serverless backend, providing automatic synchronization, type safety, and serverless functions.

## 1. Installation & Setup Steps

### 1.1 Core Dependencies Installation

```bash
# Navigate to project directory
cd kitchentory

# Install Convex
npm install convex

# Install Convex Next.js integration
npm install @convex-dev/nextjs

# Install authentication dependencies
npm install @clerk/nextjs @clerk/convex

# Install additional utilities
npm install zod lucide-react
```

### 1.2 Convex Project Initialization

```bash
# Initialize Convex in the project
npx convex dev --once

# This creates:
# - convex/ directory
# - convex.json configuration file
# - Generated types in convex/_generated/
```

### 1.3 Project Structure After Installation

```
kitchentory/
├── convex/
│   ├── _generated/           # Auto-generated by Convex
│   │   ├── api.d.ts
│   │   ├── dataModel.d.ts
│   │   └── server.d.ts
│   ├── auth.config.js        # Clerk integration
│   ├── schema.ts             # Database schema
│   ├── households.ts         # Household functions
│   ├── categories.ts         # Category functions
│   ├── products.ts           # Product functions
│   ├── storageLocations.ts   # Storage location functions
│   ├── inventoryItems.ts     # Inventory item functions
│   └── lib/
│       ├── auth.ts           # Auth utilities
│       └── utils.ts          # Helper functions
├── src/
│   ├── app/
│   │   ├── globals.css
│   │   ├── layout.tsx        # Root layout with providers
│   │   └── convex-client-provider.tsx
│   ├── components/
│   │   ├── providers/        # Context providers
│   │   └── ui/              # shadcn/ui components
│   └── lib/
│       ├── types.ts         # TypeScript types
│       └── utils.ts         # Utility functions
├── convex.json
├── next.config.js
└── package.json
```

## 2. Database Schema Design

### 2.1 Complete Schema Definition

```typescript
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // User households - each user can have multiple households
  households: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    clerkUserId: v.string(),
    members: v.optional(v.array(v.string())), // Array of Clerk user IDs
    settings: v.optional(v.object({
      defaultExpirationWarning: v.number(), // Days before expiration to warn
      currency: v.string(),
      defaultUnits: v.object({
        weight: v.string(), // "kg", "lb", etc.
        volume: v.string(), // "ml", "cups", etc.
        quantity: v.string(), // "pieces", "items", etc.
      }),
    })),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["clerkUserId"])
    .index("by_member", ["members"]),

  // Product categories (Produce, Dairy, Meat, etc.)
  categories: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    color: v.optional(v.string()), // Hex color for UI
    icon: v.optional(v.string()), // Icon name from Lucide
    householdId: v.id("households"),
    isDefault: v.optional(v.boolean()), // System-provided categories
    sortOrder: v.optional(v.number()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_household_and_sort", ["householdId", "sortOrder"])
    .index("by_default", ["isDefault"]),

  // Products (master list of all food items)
  products: defineTable({
    name: v.string(),
    brand: v.optional(v.string()),
    barcode: v.optional(v.string()),
    upc: v.optional(v.string()),
    categoryId: v.id("categories"),
    defaultUnit: v.string(),
    defaultQuantity: v.optional(v.number()),
    description: v.optional(v.string()),
    imageUrl: v.optional(v.string()),
    imageStorageId: v.optional(v.id("_storage")),
    
    // Nutritional information (optional)
    nutrition: v.optional(v.object({
      calories: v.optional(v.number()),
      protein: v.optional(v.number()),
      carbs: v.optional(v.number()),
      fat: v.optional(v.number()),
      fiber: v.optional(v.number()),
      sugar: v.optional(v.number()),
      sodium: v.optional(v.number()),
      servingSize: v.optional(v.string()),
    })),
    
    // Storage recommendations
    storageInfo: v.optional(v.object({
      temperature: v.optional(v.string()), // "cold", "frozen", "room"
      humidity: v.optional(v.string()), // "high", "low", "medium"
      lightSensitive: v.optional(v.boolean()),
      shelfLife: v.optional(v.number()), // Days
    })),
    
    isVerified: v.optional(v.boolean()), // Community verified
    submittedBy: v.optional(v.string()), // User who submitted
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_category", ["categoryId"])
    .index("by_barcode", ["barcode"])
    .index("by_upc", ["upc"])
    .index("by_name", ["name"])
    .index("by_name_and_brand", ["name", "brand"]),

  // Storage locations (Fridge, Freezer, Pantry, etc.)
  storageLocations: defineTable({
    name: v.string(),
    locationType: v.union(
      v.literal("fridge"),
      v.literal("freezer"),
      v.literal("pantry"),
      v.literal("counter"),
      v.literal("cabinet"),
      v.literal("wine_cellar"),
      v.literal("outdoor"),
      v.literal("other")
    ),
    
    // Physical properties
    temperature: v.optional(v.object({
      min: v.number(),
      max: v.number(),
      unit: v.string(), // "celsius", "fahrenheit"
    })),
    capacity: v.optional(v.object({
      volume: v.number(),
      unit: v.string(), // "liters", "cubic_feet"
    })),
    
    description: v.optional(v.string()),
    notes: v.optional(v.string()),
    householdId: v.id("households"),
    isActive: v.optional(v.boolean()),
    sortOrder: v.optional(v.number()),
    
    // Smart features
    hasTemperatureMonitoring: v.optional(v.boolean()),
    hasInventoryTracking: v.optional(v.boolean()),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_household_and_type", ["householdId", "locationType"])
    .index("by_household_and_sort", ["householdId", "sortOrder"])
    .index("by_active", ["isActive"]),

  // Individual inventory items
  inventoryItems: defineTable({
    productId: v.id("products"),
    quantity: v.number(),
    unit: v.string(),
    locationId: v.id("storageLocations"),
    householdId: v.id("households"),
    
    // Dates
    expirationDate: v.optional(v.string()), // ISO date string
    purchaseDate: v.optional(v.string()),
    openedDate: v.optional(v.string()),
    
    // Purchase info
    price: v.optional(v.number()),
    store: v.optional(v.string()),
    receiptId: v.optional(v.string()),
    
    // Status
    status: v.union(
      v.literal("fresh"),
      v.literal("expiring_soon"),
      v.literal("expired"),
      v.literal("consumed"),
      v.literal("discarded")
    ),
    
    // Additional info
    notes: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    lot: v.optional(v.string()), // Batch/lot number
    
    // Tracking
    addedBy: v.string(), // Clerk user ID
    lastUpdatedBy: v.string(),
    consumedBy: v.optional(v.string()),
    
    // Alerts
    lowStockThreshold: v.optional(v.number()),
    expirationAlertSent: v.optional(v.boolean()),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_location", ["locationId"])
    .index("by_product", ["productId"])
    .index("by_expiration", ["expirationDate"])
    .index("by_status", ["status"])
    .index("by_household_and_expiration", ["householdId", "expirationDate"])
    .index("by_household_and_status", ["householdId", "status"])
    .index("by_added_by", ["addedBy"]),

  // Shopping lists
  shoppingLists: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    householdId: v.id("households"),
    createdBy: v.string(), // Clerk user ID
    
    status: v.union(
      v.literal("draft"),
      v.literal("active"),
      v.literal("shopping"),
      v.literal("completed"),
      v.literal("archived")
    ),
    
    // Settings
    isDefault: v.optional(v.boolean()),
    autoGenerate: v.optional(v.boolean()), // Auto-add low stock items
    
    // Collaboration
    sharedWith: v.optional(v.array(v.string())), // Clerk user IDs
    allowEditing: v.optional(v.boolean()),
    
    // Shopping session
    shoppingStartedAt: v.optional(v.number()),
    shoppingCompletedAt: v.optional(v.number()),
    totalEstimatedCost: v.optional(v.number()),
    actualCost: v.optional(v.number()),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_created_by", ["createdBy"])
    .index("by_status", ["status"])
    .index("by_shared_with", ["sharedWith"]),

  // Shopping list items
  shoppingListItems: defineTable({
    listId: v.id("shoppingLists"),
    productId: v.optional(v.id("products")), // Optional for custom items
    
    // Item details
    name: v.string(), // Product name or custom name
    brand: v.optional(v.string()),
    quantity: v.number(),
    unit: v.string(),
    category: v.optional(v.string()),
    
    // Shopping info
    estimatedPrice: v.optional(v.number()),
    actualPrice: v.optional(v.number()),
    store: v.optional(v.string()),
    aisle: v.optional(v.string()),
    
    // Status
    isCompleted: v.boolean(),
    isPriority: v.optional(v.boolean()),
    isOptional: v.optional(v.boolean()),
    
    // Tracking
    addedBy: v.string(),
    completedBy: v.optional(v.string()),
    completedAt: v.optional(v.number()),
    
    // Auto-generated from inventory
    triggeredBy: v.optional(v.union(
      v.literal("low_stock"),
      v.literal("expired"),
      v.literal("recipe"),
      v.literal("manual")
    )),
    sourceItemId: v.optional(v.id("inventoryItems")),
    
    notes: v.optional(v.string()),
    sortOrder: v.optional(v.number()),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_list", ["listId"])
    .index("by_list_and_completed", ["listId", "isCompleted"])
    .index("by_list_and_sort", ["listId", "sortOrder"])
    .index("by_product", ["productId"])
    .index("by_added_by", ["addedBy"]),

  // Recipe management (basic structure for future enhancement)
  recipes: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    
    // Recipe details
    servings: v.number(),
    prepTime: v.optional(v.number()), // Minutes
    cookTime: v.optional(v.number()),
    totalTime: v.optional(v.number()),
    difficulty: v.optional(v.union(
      v.literal("easy"),
      v.literal("medium"),
      v.literal("hard")
    )),
    
    // Content
    ingredients: v.array(v.object({
      productId: v.optional(v.id("products")),
      name: v.string(),
      quantity: v.number(),
      unit: v.string(),
      isOptional: v.optional(v.boolean()),
      notes: v.optional(v.string()),
    })),
    instructions: v.array(v.string()),
    
    // Metadata
    cuisine: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    imageUrl: v.optional(v.string()),
    imageStorageId: v.optional(v.id("_storage")),
    sourceUrl: v.optional(v.string()),
    
    // User data
    createdBy: v.string(), // Clerk user ID
    isPublic: v.optional(v.boolean()),
    householdId: v.optional(v.id("households")), // Private to household if set
    
    // Engagement
    rating: v.optional(v.number()),
    ratingCount: v.optional(v.number()),
    favoriteCount: v.optional(v.number()),
    
    // Nutrition (calculated from ingredients)
    nutrition: v.optional(v.object({
      calories: v.number(),
      protein: v.number(),
      carbs: v.number(),
      fat: v.number(),
      fiber: v.number(),
    })),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_created_by", ["createdBy"])
    .index("by_household", ["householdId"])
    .index("by_public", ["isPublic"])
    .index("by_cuisine", ["cuisine"])
    .index("by_rating", ["rating"]),

  // Activity log for audit trail
  activityLog: defineTable({
    householdId: v.id("households"),
    userId: v.string(), // Clerk user ID
    
    action: v.union(
      v.literal("item_added"),
      v.literal("item_consumed"),
      v.literal("item_expired"),
      v.literal("item_updated"),
      v.literal("location_created"),
      v.literal("category_created"),
      v.literal("recipe_cooked"),
      v.literal("shopping_completed")
    ),
    
    // Structured data for each action type
    details: v.object({
      itemId: v.optional(v.id("inventoryItems")),
      productName: v.optional(v.string()),
      quantity: v.optional(v.number()),
      unit: v.optional(v.string()),
      location: v.optional(v.string()),
      previousValue: v.optional(v.any()), // For updates
      newValue: v.optional(v.any()),
    }),
    
    notes: v.optional(v.string()),
    timestamp: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_user", ["userId"])
    .index("by_household_and_timestamp", ["householdId", "timestamp"])
    .index("by_action", ["action"]),

  // User preferences and settings
  userPreferences: defineTable({
    clerkUserId: v.string(),
    
    // UI preferences
    theme: v.optional(v.union(v.literal("light"), v.literal("dark"), v.literal("system"))),
    language: v.optional(v.string()),
    dateFormat: v.optional(v.string()),
    numberFormat: v.optional(v.string()),
    
    // Notification preferences
    notifications: v.object({
      expirationWarnings: v.boolean(),
      lowStockAlerts: v.boolean(),
      shoppingReminders: v.boolean(),
      weeklyDigest: v.boolean(),
      emailNotifications: v.boolean(),
      pushNotifications: v.boolean(),
    }),
    
    // App preferences
    defaultView: v.optional(v.union(
      v.literal("inventory"),
      v.literal("shopping"),
      v.literal("recipes"),
      v.literal("dashboard")
    )),
    quickAddLocation: v.optional(v.id("storageLocations")),
    
    // Privacy settings
    dataSharing: v.object({
      analytics: v.boolean(),
      productDatabase: v.boolean(),
      recipeRecommendations: v.boolean(),
    }),
    
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["clerkUserId"]),
});
```

### 2.2 Schema Features Explanation

- **Comprehensive Indexing**: All tables include strategic indexes for efficient queries
- **Real-time Ready**: All tables support real-time subscriptions
- **Flexible Data Types**: Uses Convex's type system with optional fields and unions
- **Audit Trail**: Activity logging for all important actions
- **Multi-tenant**: All data is scoped to households for proper data isolation
- **Future-proof**: Schema supports advanced features like nutrition tracking, recipe management

## 3. Real-Time Subscription Patterns

### 3.1 Component Subscription Patterns

```typescript
// components/InventoryList.tsx
import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";

export function InventoryList() {
  // Real-time inventory subscription
  const items = useQuery(api.inventoryItems.list, {
    categoryId: undefined,
    locationId: undefined,
    status: "fresh",
  });

  const expiringItems = useQuery(api.inventoryItems.list, {
    status: "expiring_soon",
  });

  const stats = useQuery(api.inventoryItems.getStats);

  if (items === undefined) return <div>Loading...</div>;

  return (
    <div>
      <h2>Inventory ({items.length} items)</h2>
      <div>
        {stats && (
          <div className="stats">
            <span>Expiring Soon: {stats.expiringSoon}</span>
            <span>Expired: {stats.expiredItems}</span>
          </div>
        )}
      </div>
      <div>
        {items.map((item) => (
          <InventoryItemCard key={item._id} item={item} />
        ))}
      </div>
    </div>
  );
}
```

### 3.2 Optimistic Updates Pattern

```typescript
// hooks/useOptimisticInventory.ts
import { useMutation, useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useState } from "react";

export function useOptimisticInventory() {
  const [optimisticItems, setOptimisticItems] = useState<Map<string, any>>(new Map());
  const addItem = useMutation(api.inventoryItems.create);
  const consumeItem = useMutation(api.inventoryItems.consume);
  
  const handleAddItem = async (itemData: any) => {
    // Generate temporary ID for optimistic update
    const tempId = `temp-${Date.now()}`;
    
    // Add optimistic item to local state
    setOptimisticItems(prev => new Map(prev).set(tempId, {
      ...itemData,
      _id: tempId,
      _creationTime: Date.now(),
      status: "fresh",
    }));

    try {
      const result = await addItem(itemData);
      // Remove optimistic item when real item is created
      setOptimisticItems(prev => {
        const next = new Map(prev);
        next.delete(tempId);
        return next;
      });
      return result;
    } catch (error) {
      // Remove failed optimistic update
      setOptimisticItems(prev => {
        const next = new Map(prev);
        next.delete(tempId);
        return next;
      });
      throw error;
    }
  };

  const handleConsumeItem = async (itemId: string) => {
    // Optimistically mark as consumed
    setOptimisticItems(prev => new Map(prev).set(itemId, {
      status: "consumed",
      _id: itemId,
    }));

    try {
      await consumeItem({ id: itemId });
      // Remove from optimistic updates when confirmed
      setOptimisticItems(prev => {
        const next = new Map(prev);
        next.delete(itemId);
        return next;
      });
    } catch (error) {
      // Revert optimistic update on failure
      setOptimisticItems(prev => {
        const next = new Map(prev);
        next.delete(itemId);
        return next;
      });
      throw error;
    }
  };

  return {
    optimisticItems: Array.from(optimisticItems.values()),
    handleAddItem,
    handleConsumeItem,
  };
}
```

### 3.3 Multi-User Collaboration Pattern

```typescript
// components/ShoppingListCollaboration.tsx
import { useQuery, useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useUser } from "@clerk/nextjs";

export function ShoppingListCollaboration({ listId }: { listId: string }) {
  const { user } = useUser();
  const list = useQuery(api.shoppingLists.get, { id: listId });
  const items = useQuery(api.shoppingListItems.list, { listId });
  const activeUsers = useQuery(api.shoppingLists.getActiveUsers, { listId });
  
  const toggleItem = useMutation(api.shoppingListItems.toggle);
  const updatePresence = useMutation(api.shoppingLists.updatePresence);

  // Update presence every 30 seconds
  useEffect(() => {
    const interval = setInterval(() => {
      updatePresence({ listId, userId: user?.id });
    }, 30000);
    return () => clearInterval(interval);
  }, [listId, user?.id]);

  return (
    <div>
      <div className="collaboration-header">
        <h2>{list?.name}</h2>
        <div className="active-users">
          {activeUsers?.map(user => (
            <div key={user.id} className="user-avatar">
              {user.name}
            </div>
          ))}
        </div>
      </div>
      
      <div className="items-list">
        {items?.map((item) => (
          <div 
            key={item._id}
            className={`item ${item.isCompleted ? 'completed' : ''}`}
          >
            <input
              type="checkbox"
              checked={item.isCompleted}
              onChange={() => toggleItem({ 
                id: item._id, 
                completedBy: user?.id 
              })}
            />
            <span>{item.name}</span>
            {item.completedBy && item.completedBy !== user?.id && (
              <span className="completed-by">✓ by {item.completedBy}</span>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
```

## 4. Authentication Integration with Clerk

### 4.1 Convex Auth Configuration

```javascript
// convex/auth.config.js
export default {
  providers: [
    {
      domain: process.env.CLERK_JWT_ISSUER_DOMAIN,
      applicationID: "convex",
    },
  ]
};
```

### 4.2 Root Layout Setup

```typescript
// src/app/layout.tsx
import { ClerkProvider } from '@clerk/nextjs';
import { ConvexClientProvider } from './convex-client-provider';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <ClerkProvider publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY!}>
          <ConvexClientProvider>
            {children}
          </ConvexClientProvider>
        </ClerkProvider>
      </body>
    </html>
  );
}
```

### 4.3 Convex Client Provider

```typescript
// src/app/convex-client-provider.tsx
'use client';

import { ClerkProvider, useAuth } from '@clerk/nextjs';
import { ConvexProviderWithClerk } from 'convex/react-clerk';
import { ConvexReactClient } from 'convex/react';
import { ReactNode } from 'react';

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return (
    <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
      {children}
    </ConvexProviderWithClerk>
  );
}
```

### 4.4 Authentication Middleware

```typescript
// convex/lib/auth.ts
import { Auth } from "convex/server";
import { GenericQueryCtx, GenericMutationCtx } from "convex/server";
import { DataModel } from "./_generated/dataModel";

export async function getUser(
  ctx: GenericQueryCtx<DataModel> | GenericMutationCtx<DataModel>
) {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) {
    throw new Error("Not authenticated");
  }
  return identity;
}

export async function getUserHousehold(
  ctx: GenericQueryCtx<DataModel> | GenericMutationCtx<DataModel>
) {
  const identity = await getUser(ctx);
  
  const household = await ctx.db
    .query("households")
    .withIndex("by_user", (q) => q.eq("clerkUserId", identity.subject))
    .first();

  if (!household) {
    throw new Error("No household found for user");
  }

  return household;
}

export async function requireHouseholdAccess(
  ctx: GenericQueryCtx<DataModel> | GenericMutationCtx<DataModel>,
  householdId: string
) {
  const identity = await getUser(ctx);
  
  const household = await ctx.db.get(householdId);
  if (!household) {
    throw new Error("Household not found");
  }

  const hasAccess = household.clerkUserId === identity.subject ||
    household.members?.includes(identity.subject);

  if (!hasAccess) {
    throw new Error("Access denied to household");
  }

  return household;
}
```

## 5. File Structure for Convex Functions

### 5.1 Core Function Files

#### 5.1.1 Household Functions

```typescript
// convex/households.ts
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { getUser } from "./lib/auth";

export const create = mutation({
  args: {
    name: v.string(),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await getUser(ctx);
    
    const household = await ctx.db.insert("households", {
      ...args,
      clerkUserId: identity.subject,
      settings: {
        defaultExpirationWarning: 7,
        currency: "USD",
        defaultUnits: {
          weight: "kg",
          volume: "ml",
          quantity: "pieces",
        },
      },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    // Create default categories
    await createDefaultCategories(ctx, household);
    
    // Create default storage locations
    await createDefaultStorageLocations(ctx, household);

    return household;
  },
});

export const get = query({
  args: {},
  handler: async (ctx) => {
    const identity = await getUser(ctx);
    
    return await ctx.db
      .query("households")
      .withIndex("by_user", (q) => q.eq("clerkUserId", identity.subject))
      .first();
  },
});

export const update = mutation({
  args: {
    name: v.optional(v.string()),
    description: v.optional(v.string()),
    settings: v.optional(v.object({
      defaultExpirationWarning: v.number(),
      currency: v.string(),
      defaultUnits: v.object({
        weight: v.string(),
        volume: v.string(),
        quantity: v.string(),
      }),
    })),
  },
  handler: async (ctx, args) => {
    const identity = await getUser(ctx);
    
    const household = await ctx.db
      .query("households")
      .withIndex("by_user", (q) => q.eq("clerkUserId", identity.subject))
      .first();

    if (!household) throw new Error("Household not found");

    return await ctx.db.patch(household._id, {
      ...args,
      updatedAt: Date.now(),
    });
  },
});

async function createDefaultCategories(ctx: any, householdId: string) {
  const defaultCategories = [
    { name: "Produce", color: "#22c55e", icon: "apple" },
    { name: "Dairy", color: "#3b82f6", icon: "milk" },
    { name: "Meat", color: "#dc2626", icon: "beef" },
    { name: "Pantry", color: "#f59e0b", icon: "cookie" },
    { name: "Beverages", color: "#06b6d4", icon: "coffee" },
    { name: "Frozen", color: "#8b5cf6", icon: "snowflake" },
  ];

  for (const [index, category] of defaultCategories.entries()) {
    await ctx.db.insert("categories", {
      ...category,
      householdId,
      isDefault: true,
      sortOrder: index,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
  }
}

async function createDefaultStorageLocations(ctx: any, householdId: string) {
  const defaultLocations = [
    { 
      name: "Refrigerator", 
      locationType: "fridge",
      temperature: { min: 1, max: 4, unit: "celsius" }
    },
    { 
      name: "Freezer", 
      locationType: "freezer",
      temperature: { min: -18, max: -15, unit: "celsius" }
    },
    { name: "Pantry", locationType: "pantry" },
    { name: "Counter", locationType: "counter" },
  ];

  for (const [index, location] of defaultLocations.entries()) {
    await ctx.db.insert("storageLocations", {
      ...location,
      householdId,
      isActive: true,
      sortOrder: index,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
  }
}
```

#### 5.1.2 Inventory Items Functions

```typescript
// convex/inventoryItems.ts
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { getUserHousehold, requireHouseholdAccess } from "./lib/auth";

export const list = query({
  args: {
    categoryId: v.optional(v.id("categories")),
    locationId: v.optional(v.id("storageLocations")),
    status: v.optional(v.union(
      v.literal("fresh"),
      v.literal("expiring_soon"),
      v.literal("expired"),
      v.literal("consumed"),
      v.literal("discarded")
    )),
    search: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const household = await getUserHousehold(ctx);
    
    let items = await ctx.db
      .query("inventoryItems")
      .withIndex("by_household", (q) => q.eq("householdId", household._id))
      .collect();

    // Apply filters
    if (args.locationId) {
      items = items.filter(item => item.locationId === args.locationId);
    }

    if (args.status) {
      items = items.filter(item => item.status === args.status);
    }

    // Get related data with efficient parallel fetching
    const itemsWithDetails = await Promise.all(
      items.map(async (item) => {
        const [product, location] = await Promise.all([
          ctx.db.get(item.productId),
          ctx.db.get(item.locationId),
        ]);
        
        const category = product ? await ctx.db.get(product.categoryId) : null;
        
        return {
          ...item,
          product,
          location,
          category,
        };
      })
    );

    // Apply search filter
    if (args.search) {
      const searchTerm = args.search.toLowerCase();
      const filtered = itemsWithDetails.filter((item) =>
        item.product?.name.toLowerCase().includes(searchTerm) ||
        item.product?.brand?.toLowerCase().includes(searchTerm) ||
        item.notes?.toLowerCase().includes(searchTerm)
      );
      
      return args.limit ? filtered.slice(0, args.limit) : filtered;
    }

    return args.limit ? itemsWithDetails.slice(0, args.limit) : itemsWithDetails;
  },
});

export const create = mutation({
  args: {
    productId: v.id("products"),
    quantity: v.number(),
    unit: v.string(),
    locationId: v.id("storageLocations"),
    expirationDate: v.optional(v.string()),
    purchaseDate: v.optional(v.string()),
    price: v.optional(v.number()),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const household = await getUserHousehold(ctx);
    const identity = await ctx.auth.getUserIdentity();
    
    // Validate references exist and user has access
    const [product, location] = await Promise.all([
      ctx.db.get(args.productId),
      ctx.db.get(args.locationId),
    ]);

    if (!product) throw new Error("Product not found");
    if (!location) throw new Error("Storage location not found");
    if (location.householdId !== household._id) {
      throw new Error("Storage location not accessible");
    }

    // Determine status based on expiration date
    const status = calculateItemStatus(args.expirationDate);
    
    const now = Date.now();
    const itemId = await ctx.db.insert("inventoryItems", {
      ...args,
      householdId: household._id,
      status,
      addedBy: identity!.subject,
      lastUpdatedBy: identity!.subject,
      createdAt: now,
      updatedAt: now,
    });

    // Log activity
    await ctx.db.insert("activityLog", {
      householdId: household._id,
      userId: identity!.subject,
      action: "item_added",
      details: {
        itemId,
        productName: product.name,
        quantity: args.quantity,
        unit: args.unit,
        location: location.name,
      },
      timestamp: now,
    });

    return itemId;
  },
});

export const consume = mutation({
  args: { 
    id: v.id("inventoryItems"),
    consumedQuantity: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    const item = await ctx.db.get(args.id);
    
    if (!item) throw new Error("Item not found");
    
    await requireHouseholdAccess(ctx, item.householdId);

    const product = await ctx.db.get(item.productId);
    const location = await ctx.db.get(item.locationId);

    if (args.consumedQuantity && args.consumedQuantity < item.quantity) {
      // Partial consumption - update quantity
      await ctx.db.patch(args.id, {
        quantity: item.quantity - args.consumedQuantity,
        lastUpdatedBy: identity!.subject,
        updatedAt: Date.now(),
      });
    } else {
      // Full consumption - mark as consumed
      await ctx.db.patch(args.id, {
        status: "consumed",
        consumedBy: identity!.subject,
        lastUpdatedBy: identity!.subject,
        updatedAt: Date.now(),
      });
    }

    // Log activity
    await ctx.db.insert("activityLog", {
      householdId: item.householdId,
      userId: identity!.subject,
      action: "item_consumed",
      details: {
        itemId: args.id,
        productName: product?.name,
        quantity: args.consumedQuantity || item.quantity,
        unit: item.unit,
        location: location?.name,
      },
      timestamp: Date.now(),
    });

    return true;
  },
});

export const getStats = query({
  handler: async (ctx) => {
    const household = await getUserHousehold(ctx);
    
    const items = await ctx.db
      .query("inventoryItems")
      .withIndex("by_household", (q) => q.eq("householdId", household._id))
      .collect();

    const activeItems = items.filter(item => 
      item.status !== "consumed" && item.status !== "discarded"
    );

    const expiredItems = activeItems.filter(item => item.status === "expired");
    const expiringSoon = activeItems.filter(item => item.status === "expiring_soon");

    // Calculate category and location statistics
    const categoryStats = new Map<string, number>();
    const locationStats = new Map<string, number>();

    await Promise.all(
      activeItems.map(async (item) => {
        const [product, location] = await Promise.all([
          ctx.db.get(item.productId),
          ctx.db.get(item.locationId),
        ]);
        
        if (product) {
          const category = await ctx.db.get(product.categoryId);
          if (category) {
            categoryStats.set(category.name, (categoryStats.get(category.name) || 0) + 1);
          }
        }
        
        if (location) {
          locationStats.set(location.name, (locationStats.get(location.name) || 0) + 1);
        }
      })
    );

    const topCategories = Array.from(categoryStats.entries())
      .map(([name, count]) => ({ name, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    const topLocations = Array.from(locationStats.entries())
      .map(([name, count]) => ({ name, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    return {
      totalItems: activeItems.length,
      expiredItems: expiredItems.length,
      expiringSoon: expiringSoon.length,
      topCategories,
      topLocations,
    };
  },
});

function calculateItemStatus(expirationDate?: string) {
  if (!expirationDate) return "fresh";
  
  const today = new Date();
  const expDate = new Date(expirationDate);
  const daysUntilExpiry = Math.ceil((expDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
  
  if (daysUntilExpiry < 0) return "expired";
  if (daysUntilExpiry <= 3) return "expiring_soon";
  return "fresh";
}
```

### 5.2 Additional Function Files

The following files should be created following similar patterns:

- `convex/categories.ts` - Category CRUD operations
- `convex/products.ts` - Product search and management
- `convex/storageLocations.ts` - Storage location management
- `convex/shoppingLists.ts` - Shopping list operations
- `convex/recipes.ts` - Recipe matching and management
- `convex/userPreferences.ts` - User settings management
- `convex/cron.ts` - Scheduled tasks for expiration alerts
- `convex/actions.ts` - External API integrations

## 6. Environment Variable Requirements

### 6.1 Required Environment Variables

```bash
# .env.local

# Convex
CONVEX_DEPLOYMENT=dev:your-deployment-name
NEXT_PUBLIC_CONVEX_URL=https://your-deployment-name.convex.cloud

# Clerk Authentication
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
CLERK_JWT_ISSUER_DOMAIN=https://your-clerk-domain.clerk.accounts.dev

# Webhooks
CLERK_WEBHOOK_SECRET=whsec_...

# Optional External APIs
SPOONACULAR_API_KEY=your-api-key
UPC_DATABASE_API_KEY=your-api-key

# Production only
CONVEX_DEPLOY_KEY=your-deploy-key
```

### 6.2 Environment Variable Setup Script

```bash
# scripts/setup-env.sh
#!/bin/bash

echo "Setting up Kitchentory environment variables..."

# Check if .env.local exists
if [ ! -f .env.local ]; then
    cp .env.example .env.local
    echo "Created .env.local from .env.example"
fi

# Check Convex deployment
if ! grep -q "CONVEX_DEPLOYMENT=" .env.local; then
    echo "Please run 'npx convex dev' to get your Convex deployment URL"
    echo "Then add it to .env.local"
fi

# Check Clerk keys
if ! grep -q "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=" .env.local; then
    echo "Please add your Clerk publishable key to .env.local"
    echo "Get it from: https://dashboard.clerk.dev"
fi

echo "Environment setup complete!"
echo "Don't forget to configure:"
echo "1. Clerk webhook endpoints"
echo "2. External API keys for barcode/recipe services"
echo "3. Production deployment keys"
```

## 7. Development Workflow for Schema Changes

### 7.1 Schema Migration Process

```bash
# 1. Update schema definition
# Edit convex/schema.ts with new tables or fields

# 2. Run development with schema validation
npx convex dev

# 3. Test schema changes locally
npm run dev

# 4. Run type generation
npx convex codegen

# 5. Update TypeScript types
npm run typecheck

# 6. Commit schema changes
git add convex/schema.ts convex/_generated/
git commit -m "feat: update database schema for [feature]"

# 7. Deploy to production
npx convex deploy --prod
```

### 7.2 Data Migration Strategies

```typescript
// convex/migrations/001_add_nutrition_fields.ts
import { internalMutation } from "./_generated/server";

export default internalMutation({
  handler: async (ctx) => {
    // Get all products without nutrition info
    const products = await ctx.db
      .query("products")
      .filter(q => q.eq(q.field("nutrition"), undefined))
      .collect();

    // Add default nutrition structure
    for (const product of products) {
      await ctx.db.patch(product._id, {
        nutrition: {
          calories: 0,
          protein: 0,
          carbs: 0,
          fat: 0,
        },
        updatedAt: Date.now(),
      });
    }

    console.log(`Migrated ${products.length} products`);
  },
});
```

### 7.3 Schema Validation Helpers

```typescript
// convex/lib/validators.ts
import { v } from "convex/values";

// Reusable validators for common patterns
export const timestampFields = {
  createdAt: v.number(),
  updatedAt: v.number(),
};

export const householdScoped = {
  householdId: v.id("households"),
};

export const userTracked = {
  addedBy: v.string(),
  lastUpdatedBy: v.string(),
};

export const nutritionInfo = v.object({
  calories: v.optional(v.number()),
  protein: v.optional(v.number()),
  carbs: v.optional(v.number()),
  fat: v.optional(v.number()),
  fiber: v.optional(v.number()),
  sugar: v.optional(v.number()),
  sodium: v.optional(v.number()),
  servingSize: v.optional(v.string()),
});

// Common validation functions
export function validateQuantity(quantity: number): void {
  if (quantity <= 0) {
    throw new Error("Quantity must be greater than 0");
  }
}

export function validateExpirationDate(date?: string): void {
  if (date && isNaN(Date.parse(date))) {
    throw new Error("Invalid expiration date format");
  }
}
```

### 7.4 Development Best Practices

#### 7.4.1 Function Organization

```typescript
// Organize functions by domain, not by CRUD operation
// ✅ Good
convex/
├── inventoryItems/
│   ├── queries.ts      // All read operations
│   ├── mutations.ts    // All write operations
│   ├── actions.ts      // External API calls
│   └── validators.ts   // Domain-specific validation

// ❌ Avoid
convex/
├── queries.ts          // All queries mixed together
├── mutations.ts        // All mutations mixed together
└── actions.ts          // All actions mixed together
```

#### 7.4.2 Error Handling Patterns

```typescript
// convex/lib/errors.ts
import { ConvexError } from "convex/values";

export class KitchentoryError extends ConvexError {
  constructor(message: string, data?: any) {
    super(message);
    this.data = { ...data, timestamp: Date.now() };
  }
}

export function handleDatabaseError(error: unknown, context: string) {
  console.error(`Database error in ${context}:`, error);
  
  if (error instanceof ConvexError) {
    throw error;
  }
  
  throw new KitchentoryError(
    `Internal error in ${context}`, 
    { originalError: error }
  );
}
```

#### 7.4.3 Testing Strategy

```typescript
// convex/lib/testing.ts
import { ConvexTestingHelper } from "convex/testing";
import { api } from "./_generated/api";

export async function createTestHousehold(t: ConvexTestingHelper) {
  const userId = "test-user-123";
  
  // Mock authentication
  t.withIdentity({ subject: userId, issuer: "test" }, async () => {
    const household = await t.mutation(api.households.create, {
      name: "Test Household",
    });
    
    return household;
  });
}

export async function createTestProduct(
  t: ConvexTestingHelper, 
  categoryId: string
) {
  return await t.mutation(api.products.create, {
    name: "Test Product",
    categoryId,
    defaultUnit: "pieces",
  });
}
```

## 8. Performance Optimization Guidelines

### 8.1 Query Optimization

```typescript
// ✅ Good - Use indexes effectively
export const getItemsByLocation = query({
  args: { locationId: v.id("storageLocations") },
  handler: async (ctx, args) => {
    // Uses index "by_location" - efficient
    return await ctx.db
      .query("inventoryItems")
      .withIndex("by_location", (q) => q.eq("locationId", args.locationId))
      .collect();
  },
});

// ❌ Avoid - Filter without index
export const getItemsByLocationBad = query({
  args: { locationId: v.id("storageLocations") },
  handler: async (ctx, args) => {
    // No index usage - inefficient for large datasets
    const allItems = await ctx.db.query("inventoryItems").collect();
    return allItems.filter(item => item.locationId === args.locationId);
  },
});
```

### 8.2 Subscription Efficiency

```typescript
// ✅ Good - Specific subscriptions
function InventoryByLocation({ locationId }: { locationId: string }) {
  const items = useQuery(api.inventoryItems.list, { 
    locationId,
    limit: 50 // Limit results
  });
  
  return <div>{/* Render items */}</div>;
}

// ❌ Avoid - Over-broad subscriptions
function InventoryAll() {
  const items = useQuery(api.inventoryItems.list, {}); // Gets ALL items
  
  return <div>{/* Render items */}</div>;
}
```

## 9. Deployment Checklist

### 9.1 Pre-Production Setup

- [ ] Environment variables configured
- [ ] Clerk webhooks configured
- [ ] Convex deployment created
- [ ] Database indexes optimized
- [ ] Error monitoring setup (Sentry)
- [ ] Performance monitoring enabled
- [ ] Backup strategy implemented

### 9.2 Production Deployment

```bash
# Deploy Convex backend
npx convex deploy --prod

# Deploy Next.js frontend to Vercel
npx vercel --prod

# Run post-deployment verification
npm run test:e2e:prod
```

### 9.3 Monitoring Setup

```typescript
// lib/monitoring.ts
import * as Sentry from "@sentry/nextjs";

export function initMonitoring() {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,
    beforeSend(event) {
      // Filter out known non-critical errors
      if (event.exception?.values?.[0]?.type === 'ChunkLoadError') {
        return null;
      }
      return event;
    },
  });
}

// Track Convex errors
export function trackConvexError(error: unknown, context: string) {
  Sentry.captureException(error, {
    tags: {
      component: 'convex',
      context,
    },
  });
}
```

## 10. Success Metrics & Monitoring

### 10.1 Key Performance Indicators

- **Real-time sync latency**: < 100ms
- **Query response time**: < 200ms
- **Mutation success rate**: > 99.9%
- **User session duration**: Track engagement
- **Feature adoption rates**: Monitor feature usage

### 10.2 Convex-Specific Monitoring

```typescript
// hooks/useConvexMetrics.ts
import { useEffect } from 'react';
import { useQuery } from 'convex/react';

export function useConvexMetrics() {
  const startTime = useRef(Date.now());
  
  useEffect(() => {
    // Track query performance
    const queryDuration = Date.now() - startTime.current;
    
    if (queryDuration > 1000) {
      console.warn('Slow Convex query detected:', queryDuration);
    }
  });
}
```

## Summary

This comprehensive Convex integration plan provides:

1. **Complete setup instructions** - From installation to deployment
2. **Production-ready schema** - Comprehensive data model for kitchen inventory
3. **Real-time patterns** - Optimized subscription and collaboration strategies
4. **Authentication integration** - Seamless Clerk + Convex setup
5. **Development workflow** - Best practices for schema evolution
6. **Performance optimization** - Guidelines for scalable operations
7. **Monitoring & metrics** - Production monitoring setup

The plan is designed to be executed immediately once the NextJS project is created, providing a solid foundation for the Kitchentory application with real-time capabilities, type safety, and scalable architecture.

All code examples are production-ready and follow Convex best practices for performance, security, and maintainability. The schema supports the full feature set outlined in the PRD while remaining flexible for future enhancements.